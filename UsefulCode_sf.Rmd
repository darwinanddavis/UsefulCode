---
title: Useful R code - sf and geodata  
author: |
 | Matthew Malishev
 | @darwinanddavis 
fontsize: 10
geometry: margin=1in
documentclass: article
linkcolor: pink
urlcolor: blue
citecolor: red
always_allow_html: yes
output:
  html_document:
    highlight: tango
    code_folding: show
    toc: yes
    toc_depth: 4
    number_sections: no
    toc_float: yes
  md_document: 
    variant: markdown_github
  pdf_document:
    includes:
      in_header: # add .tex file with header content
    highlight: tango
    template: null
    toc: yes
    toc_depth: 4
    number_sections: false
    fig_width: 4
    fig_height: 5
    fig_caption: true
    df_print: tibble 
    citation_package: biblatex # natbib
    latex_engine: xelatex #pdflatex # lualatex
    keep_tex: true # keep .tex file in dir 
  word_document:
    highlight: tango
    keep_md: yes
    pandoc_args: --smart
    #reference: mystyles.docx
    toc: yes
    toc_depth: 4
inludes:
  before_body: before_body.tex
subtitle: 
tags:
- nothing
- nothingness
params: 
  dir: "/Users/malishev/Documents/Melbourne Uni/Programs/R code/UsefulCode"
  date: !r Sys.Date()
  version: !r getRversion()
  email: "matthew.malishev [at] gmail.com"
  doi: https://github.com/darwinanddavis/UsefulCode
classoption: portrait
# ^['https://github.com/darwinanddavis/UsefulCode'] # footnote
vignette: >
  %\VignetteIndexEntry{Useful R code}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ TeX: { equationNumbers: {autoNumber: "all"} } });
</script>

```{r echo = FALSE}
 library(rmarkdown)
# setwd("")
# f <- list.files()[1]
# render(f, output_format='pdf_document')
# render(f, output_format='pdf_document')
```

```{r, set-options, echo = FALSE, cache = FALSE}
options(width=100)
knitr::opts_chunk$set(
 eval = F, # run all code
 results='hide',
 # echo = FALSE, # show code chunks in output 
 comment = "",
 tidy.opts=list(width.cutoff=100), # set width of code chunks in output
 tidy=TRUE, # make output as tidy
 message = FALSE,  # mask all messages
 warning = FALSE, # mask all warnings 
 collapse = T,
 size="small" # set code chunk size
)

# https://github.com/ucb-stat133/stat133-fall-2016/blob/master/hws/hw02-tables-ggplot.Rmd
knitr::opts_knit$set(root.dir=paste0(params$dir,"/")) # set working dir

setwd(paste0(params$dir,"/")) # for running just in R not knitr
pacman::p_load(dplyr,readr,rvest,xml2,magrittr,sp,sf,rgdal,ggmap,ggplot2,stringr,ggthemes,ggnetwork,colorspace,ggtext,ggsn,ggspatial,showtext,here)
```

\  

Date: `r params$date`  
`R` version: `r params$version`  
*Corresponding author: `r params$email`  
This document can be found at `r params$doi`

\newpage  

## Overview

Accessing sf, sp, geos,a nd geojson objects, such as attributes, accessing lower levels of their structure, latlon and MULTIPOLYGONS layers, etc.  

<!-- ideas -->
<!-- https://r-spatial.github.io/sf/articles/sf1.html -->
<!-- https://nceas.github.io/oss-lessons/spatial-data-gis-law/3-mon-intro-gis-in-r.html -->

### json  

Read and convert json to df
```{r, eval = F}

# opt 1
require(jsonlite)
data <- fromJSON("data.json",simplifyDataFrame=T,flatten=T) %>% 
  as.data.frame(data)

# opt 2
file <- "my_geo_data.json" %>% 
  readr::read_lines


```


### sf simple features  
Get bbox coords      
```{r, sf1, collapse=T}
require(sf)
methods(class="sf")
obj$geometry %>% attr(which = "bbox")

```

Get first element or range of sf  
```{r, sf2}
obj$geometry
obj$geometry[1] %>% unlist %>% .[1] # first element
obj %>% st_coordinates() %>% .[1:3] # coord range    
```

Get polygons (and range) in geometry layer       
```{r, sf3}
obj %>% st_geometry() %>% .[1:10] # polygon range  
```

Remove or keep/select specific sf types from sf obj
```{r, sf4}
obj %>% st_collection_extract("POINT") # get just points
obj %>% st_geometry %>% st_collection_extract("POINT") # get geometry of just points
```

Get boundary/outlines
```{r, sf5}
# good for plotting US state border lines over other sf files 
obj %>% st_geometry() %>% st_boundary %>% ggplot() + geom_sf()

# boundary of bbox
mp %>% st_bbox() %>% st_as_sfc() %>% 
  ggplot() + geom_sf()
```

Break up multipolygon into separate polygons/pull specific polygon e.g. main France polygon and rm islands
```{r, sf6, eval = F}
french_guiana <- ne_countries("large",type = "countries",returnclass = "sf") %>% 
  filter(name %in% c("France")) %>% # add french guiana 
  st_cast("POLYGON") %>% slice(1) # get just french guiana 
```

Get areas of individual polygons within multipolygon  
```{r, sf7}
dd %>% filter(name == "Netherlands") %>% 
  st_cast("POLYGON") %>% st_geometry %>% st_area()
```

Crop multipolyon boundary to surround sf obj boundary and combine into one polygon    
```{r, sf8}
dd %>% st_intersection(boundary_osm %>% st_boundary()) %>% st_cast("POLYGON")
```

Filter sf geometry only   
```{r, sf9}
dat %>% 
  filter(st_geometry_type(.) == "LINESTRING")
```

Convert matrix directly to sf
```{r, sf10}
require(sfheaders)
m %>% sf_point()
m %>% sf_multipolygon()
m %>% sf_multilinestring()
m %>% sf_linestring()

# convert list of matrices/arrays into sf
require(purrr)
require(magrittr)
require(rlist)

ls %>% 
  map(matrix, ncol = 2) %>% 
  map(magrittr::set_colnames, c("lon","lat")) %>% # rename cols
  compact() %>% # drop empty lists
  map(sfheaders::sf_multipolygon, multipolygon_id = NULL) %>%  # convert to sf
  rlist::list.rbind() # bind sfs 
  
```

### ZM features  

Return Z range for sf obj 
```{r,zm1}
sf %>% st_z_range()
```

Drop zm components 
```{r}
sf %>% st_zm()
```


### .shp files    
Read in .shp file    
```{r, s1, collapse=T}
require(rgdal)# \ rgdal 
shp <- readOGR(".shp", layer="X") # layer = name of geometry element
```

Get and transform projection  
```{r, s2}
require(rgdal)# \ rgdal   
proj4string(shp) # get projection 
spTransform(shp, CRS("+proj=longlat +datum=WGS84")) # transform projection 
```

### Base maps       
Base map from OSM    
```{r, m1}
# osm 
gg <- get_map(location,
              source="osm", 
              color="bw")

ggmap(gg, extent = "device", darken = c(0.9,"white")) +
  geom_point(data = df, aes(x,y))
```

### North arrow and scale bars  
<!-- https://www.r-spatial.org/r/2018/10/25/ggplot2-sf.html   -->
```{r, m2}
library("ggspatial")
ggplot(data = world) +
    geom_sf() +
    annotation_scale(location = "bl", width_hint = 0.5) +
    annotation_north_arrow(location = "bl", which_north = "true", 
        pad_x = unit(0.75, "in"), pad_y = unit(0.5, "in"),
        style = north_arrow_fancy_orienteering) +
    coord_sf(xlim = c(-102.15, -74.12), ylim = c(7.65, 33.97))
  
## Scale on map varies by more than 10%, scale bar may be inaccurate
```

```{r, m3}

# accessing coords in sf (complex)
# shp <- here::here("worldmaps","data","day14.shp") %>% readOGR()
# d <- shp@data # df vars
# bb <- shp@bbox #bbox
# ply <- shp@polygons # polygons 
# plyl <- ply %>% purrr::map(ggplot2::fortify)  # melt polygon class
# names(plyl) <- d$VARNAME_3 # get district name  
# ggplot() + 
#   geom_polygon(data = ply_df[[600]],
#                aes(long, lat)) 

# ply[[1]]@Polygons[[1]]@coords # works
# ply[[1]] %>% attr(which="Polygons") %>% purrr::map("coords") # works

```

<!-- ### Changing fonts in ggplot -->
<!-- https://stackoverflow.com/questions/34522732/changing-fonts-in-ggplot2 -->

### Projections  

```{r, p1}

#list of proj 
# https://proj.org/operations/projections/patterson.html
# https://spatialreference.org/ref/?search=albers&srtext=Search

require(mapdata,rnaturalworld)
### 
d <- ne_countries(scale = "large",
             type = "countries",
             country = "Japan",
             returnclass = "sf")
bb <- d$geometry %>% st_bbox()

# get current proj 
d %>% st_crs() # /sf
d %>% crs() # /raster

# transform proj options 
crsn <- 3995 # 3995 3033
plat <- 50
plon <- 0
prj <- paste0("+lat_0=",plat," +lon_0=",plon," +init=epsg:",crsn) # opt1
prj <- "+init=epsg:4326" # opt2

# transforming for diff data types
# da
ras@crs@projargs <- prj 
ras %>% st_as_sf(coords = c("lon","lat"), crs = 4326) %>% # convert city_df to sp. NB need to set initial crs to one compatible with latlon coords, e.g. 4326  
    sf::st_transform(crs = prj) # now transform proj

dl %>% st_transform(prj) # shp


dt <- d %>% st_transform("+proj=utm +zone=19 +ellps=GRS80 +datum=NAD83")
dt <- d %>% st_transform(crsn)

# quartz()
p <- ggplot(data = d) +
  geom_sf() +
  coord_sf(crs = prj) # option 1 
  coord_sf(crs = st_crs(crsn)) # option 2

# proj in string format
prj <- projection(pathm) # get proj in string format
# site2 <- elevatr::get_elev_raster(city_df,
#                                   z = zoom,
#                                   prj = prj,
#                                   expand = 3) %>%  # get elev raster
#   rasterToPoints() %>% # convert to df
#   as.data.frame    

```

Get projection info 
```{r, p2}
# find proj
crs_codes = rgdal::make_EPSG() # get all espg code and info
crs_codes %>% filter(code == 27700) %>% pull # pull espg name and code 
crs_codes[crs_codes$note %>% str_which("Austra"),"code"]

```


### KML/KMZ data  
<!-- https://mitchellgritts.com/posts/load-kml-and-kmz-files-into-r/ -->
```{r, k1}
require(sf)
path <- "/data.kml" %>% sf::st_read() # single layer kml
path <- "/data.kml" %>% sf::st_layers() # multi layer kml
# for kmz, change .kmz to .zip, then unzip and read as kml
```


### Convert sp/sf/spdf data to data frame (fortify)  
```{r, sf12}
require(rworldmap)
require(broom)
d <- getMap(resolution = "high") # get world data
d_fort <- tidy(d, region = "NAME") # fortify 
```


Convert sf geometry to df  
```{r}
require(sfheaders)
sf %>% sf_to_df
```


### Find intersecting geo points within sf objects
```{r, sf13}
require(osmdata)
require(sf)
get_osm_feature <- function(loc,key,value,geo){
  oo <- opq(loc) %>% # find location
    add_osm_feature(key = key, value = value) %>% # source key-value pair
    osmdata_sf() %>% # get sf obj
    unname_osmdata_sf() # combat sf error
  oo[[geo]] # %>% # pull geometry
}

# location, key, value 
location1 <- "melbourne australia" 
polyg <- get_osm_feature(location1, "leisure","park|natu","osm_polygons") # get osm features

# check if point intersects with polygon 
pts_inter = c(144.7695,-38.2724) %>% 
  st_point() %>% # convert into sf point
  st_sfc(crs = 4326) %>% # set prj
  st_as_sf() # convert into sf  
polyg  <- polyg %>% st_transform(4326) # match proj to above sf coords
polyg_inter <- st_intersection(polyg,pts_inter) # find intersecting point within polygon 

# plot intersecting polygon and point
st_intersection(pts_inter,polyg) %>% st_geometry()
polyg %>% filter(osm_id == "234385754") 
ggplot() +
  geom_sf(data = polyg %>% filter(osm_id == polyg_inter$osm_id)) + # plot polygon w intersecting point
  geom_sf(data = pts_inter, col = "red") + # add intersecting point
  geom_sf_text(data = pts_inter, label = "Intersecting\npoint") +
  theme_bw()

```

Other predicate funcs for sf pairs
```{r, sf14, eval = F}
st_intersects()
st_disjoint()
st_touches()
st_crosses()
st_within()
st_contains()
st_contains_properly()
st_overlaps()
st_equals()
st_covers()
st_covered_by()
st_equals_exact()
st_is_within_distance()
```

### Convert df/numeric/matrix to geometry

Convert points to linestring
```{r, sf15}
inter_df <- rbind(df1,df2,df3) %>%   
    as.matrix() %>%
    st_linestring(dim = "XY") %>% # convert points to single linestring
    st_sfc(crs = 4326) # convert sfg object to geometry 

# option 2
pathm <- city_df %>% 
  dplyr::select(lat,lon) %>% 
  as.matrix() %>% # convert points to linestring
  st_linestring(dim = "XY") %>% 
  st_sfc(crs = 4326) %>% # convert sfg object to geometry 

```

Convert each row in df to linestring
```{r, sf16}
inter_df <- rbind(df1,df2,df3) %>%
    st_as_sf(coords = c("lon","lat"), crs = 4326) %>% 
    st_geometry() %>% 
    st_cast("LINESTRING")
```

### Raster

Convert raster to various data stuctures  
```{r, r1}
ras %>% rasterToPoints() %>% as.data.frame # raster to df 
ras %>% rasterToPoints() %>% as.data.frame %>% 
  st_as_sf(coords = c("x","y"), crs = 4326) # raster to sp
```


Elevation profiles
<!-- https://rdrr.io/cran/topoDistance/man/topoProfile.html -->
```{r, r2}
pacman::p_load(topoDistance,elevatr)

# elevation raster (country tiles) 
elevp <- getData('alt', country='FRA', mask = T)
elevp$FRA_msk_alt@crs # crs
elevp$FRA_msk_alt@extent # bbox

# elevation raster
elevp2 <- elevatr::get_elev_raster(city_df[,c("lon","lat")], # get elev raster
                                   z = 3,
                                   prj <- "+proj=longlat +datum=WGS84 +no_defs"
                                   # expand = 3
                                   ) %>%  
  rasterToPoints() %>% as.data.frame 
elevp2sf <- elevp2 %>% st_as_sf(coords = c("x","y"), crs = 4326) # df to sf

# elevation points (usa only)
elevp3 <- elevatr::get_elev_point(df,
                        prj <- "+init=epsg:4326")
elevp3_fort <- tidy(elevp3$elevation, region = "elevation") # fortify 
 
# convert raster to diff classes
elevdf <- elevp %>% rasterToPoints() %>% as.data.frame # raster to df 
elevdf <- elevp %>% rasterToPoints() %>% as.data.frame %>% 
  st_as_sf(coords = c("x","y"), crs = 4326) # raster to sp

# convert lines to elev profile
pts <- df[,c("lon","lat")] %>% as.matrix() %>% SpatialPoints() # df to points
elevpath <- topoDist(elevp,pts)
topoProfile(elevp,sl,pts = 100, type = "base") # generic elev profile plot
   
# plot
qplot(data = elevp2[1:10000,],x,layer,geom = "line")
```

Summarise raster layers
```{r,r3}
cellStats(raster,stat = "min",na.rm = T) # summarise raster layers
```

Read .tiff
```{r,r4}
require(raster)
dem1 <- "srtm_20_05.tif" %>% raster()
```

Crop raster/tiff to bbox
<!-- https://gis.stackexchange.com/questions/229356/crop-a-raster-file-in-r -->
```{r}
obj <- pathm # sf object
ras <- "raster.tiff" %>% raster # load raster
e <- as(obj %>% extent(), 'SpatialPolygons') # get bbox/extent as Sp
crs(e) <- "+proj=longlat +datum=WGS84 +no_defs" # add prj
r <- crop(ras, e) # crop raster to this bbox
r <- r %>% rasterToPoints() %>% as.data.frame # convert to df for plotting 
colnames(r) <- c("x","y","z")
```

Mask/crop raster data  
<!-- https://geocompr.robinlovelace.net/raster-vector.html -->

### Spatial class
Convert sf to spatiallines obj  
```{r, sp1}
lns <- df[,c("lon","lat")] %>% as.matrix() %>% Line() # df to lines
pts <- df[,c("lon","lat")] %>% as.matrix() %>% SpatialPoints() # df to points

# sf to spatiallines 
sl <- sf$geometry %>% .[1] %>% st_zm() %>% as_Spatial() # opt 1
sl <- sf$geometry %>% .[1] %>% st_zm() %>% as("Spatial") # opt 2
```


### Globe maps
Hi-res globe map
```{r, globe1}
pacman::p_load(rnaturalearth,dplyr,sf)

inset_globe <- ne_countries("medium", type = "sovereignty", returnclass = "sf") # %>% 
  # filter(!continent %in% c("Africa","Europe"))
inset_countries <- ne_countries("medium", country = c("United States of America","Australia"), type = "sovereignty", returnclass = "sf") 
crsn <- 2163  
plat <- 5   
plon <- 180
inset_prj <- paste0("+lat_0=",plat," +lon_0=",plon," +init=epsg:",crsn) # set centered projection

inset_globe <- inset_globe %>% st_transform(inset_prj)
inset_countries <- inset_countries %>% st_transform(inset_prj)
inset_flight <- inter_df1 %>% st_transform(inset_prj) %>% st_as_sf() # convert into sf  

gp <- ggplot() +
  geom_sf(data = inset_globe, fill = adjustcolor(fg,0.7), col = NA, size = 0.1) + 
  geom_sf(data = inset_countries, fill = adjustcolor(flight_col,0.7), col = NA, size = 0.1) +
  geom_my_sf(inset_flight,flight_col,0.5,3) + # melb to la flight
  coord_sf(crs = inset_prj) +
  # theme(plot.background = element_rect(fill = "transparent")) +
  theme_nothing()
gp
```

Getting gc flight path from sf obj
```{r, globe2}
library(geosphere)
  require(sf)
get_inter_func <- function(sc1,sc2){
    gcIntermediate(
      sites_flight[sites_flight$city %in% sc1,] %>% st_geometry() %>% unlist,
      sites_flight[sites_flight$city %in% sc2,] %>% st_geometry() %>% unlist,
      n=100, addStartEnd=T, breakAtDateLine=F) %>% 
      as.data.frame()
  } %>% 
    as.matrix() %>% # convert points to linestring
    st_linestring(dim = "XY") %>% 
    st_sfc(crs = 4326) # convert sfg object to geometry 
```


### Read .gpx files (GPS track software/apps)  
```{r, gpx1}
pacman::p_load(XML,lubridate)
fd <- "/Volumes/Matt_timemachine/maptracks/2021/sep/sam/gpx/"
fh <- "day182.gpx"
gpx1 <- paste0(fd,fh) %>%  # parse gpx file
  htmlTreeParse(error = function(...) {}, useInternalNodes = T)
elev <- as.numeric(xpathSApply(gpx1, path = "//trkpt/ele", xmlValue))
times <- xpathSApply(gpx1, path = "//trkpt/time", xmlValue)
coord <- xpathSApply(gpx1, path = "//trkpt", xmlAttrs)

city_df <- tibble(lat = coord["lat",] %>% as.numeric(), 
                  lon = coord["lon",] %>% as.numeric(),
                  elev = elev, 
                  time = times %>% ymd_hms()  
                  )

# elev profile 
ggplot(data = city_df) +
  geom_line(aes(time,elev)) +
  scale_x_datetime(date_breaks = "6 hours"
                   # date_minor_breaks = "1 hour", # optional
                   # date_labels = "%M%D" # full month and year
  )


# convert gpx coords to linestring
pathgpx <- city_df %>% 
  dplyr::select(lat,lon) %>% 
  as.matrix() %>% # convert points to linestring
  st_linestring(dim = "XY") %>% 
  st_sfc(crs = 4326) %>% # convert sfg object to geometry 
  st_transform(crs = 4326) # then convert projection
  

```

Parse gpx data within kml    
First manually convert file from '.kml' to '.gpx'    
```{r, gpx2}
require(XML)
require(dplyr)
require(tidyr)
coord_id <- "//coord" # tag where lat/lon/elev data are located in file 
gpx2 <- "data/full.gpx" %>%  
  htmlTreeParse(error = function(...) {}, useInternalNodes = T)
pathgpx <- xpathSApply(gpx2, path = coord_id, xmlValue) %>% # read coords (lon,lat,elev)
  as.data.frame() %>% 
  tidyr::separate(col = ".",into = c("lon", "lat", "elev"), sep = " ", remove = T) %>% # separate char into individual values
  mutate_all(as.numeric) 

# timestamp  
time_id <- "//when" # may vary with data  
gpx2 <- "data/full.gpx" %>%
  xpathSApply(gpx2, path = time_id, xmlValue) # get timestamp  
```


### Combine, join, union sf objects     

Combine multiple sf/sfc geometries into one  
```{r, join1}
pathm <- c()  
for(pid in multipath){
  path <- kmldata %>% st_read(layer = multipath[pid])
  pathm <- rbind(pathm,path)
}
patht <- st_combine(pathm) # combine separated geometries into one geometry 
```

Join/merge df vars with sf obj (ideal for heatmap/chloropleth)   
```{r, join2}
countries1 <- df$country_name %>% unique # identify country names
mp <- ne_countries(scale = "medium", returnclass = "sf") %>% 
  filter(name %in% countries1) %>% 
  rename("country_name" = name) %>% # match var names between df and sp obj
  left_join(df,by = "country_name") # join by matched var name

```

Merge/dissolve overlapping polygon/sf boundaries into one  
<!-- https://gis.stackexchange.com/questions/206893/dissolve-only-overlapping-polygons-in-r/321259?noredirect=1#comment522831_321259 -->
```{r,join3}
dd <- rnaturalearth::ne_states(countries, returnclass = "sf")
dd2 <- ne_countries("large","sovereignty",
                    returnclass = "sf")
plot(gUnion(dd, dd2[dd, ]))
```

Snap sf objects based on proximity  
```{r, join4}
library(units)
library(sfnetworks)
sf <- sf %>% 
  st_snap(.,., tolerance = 10000) %>%  # coerces the snapping using a big tolerance value
  as_sfnetwork() # convert to network obj  
autoplot(sf)
```

Validate sfs (useful when trying combining sfs and connecting lines make weird shapes)
```{r, join5}
sf %>% st_is_valid()
sf[!st_is_valid(sf),] %>% st_make_valid()
```

### Deck.gl widget for map   
Create interactive HTML knitted from Rmd    
[{rdeck}](https://github.com/anthonynorth/rdeck)       
<!-- https://twitter.com/MilesMcBain/status/1448076055651053569   -->  

### Plotting aesthetics for geom_sf()  

Change spatial polygons into hexagon tiles
<!-- https://stackoverflow.com/questions/29374004/how-do-i-generate-a-hexagonal-grid-in-r -->

<!-- https://rstudio-pubs-static.s3.amazonaws.com/299247_d1ffbb1fce0d4cef8c68d0ec0ab1c2f5.html -->
```{r, aes1, eval = F}

dd <- rnaturalearth::ne_states(c("New Zealand"), returnclass = "sf") 

# opt 1
# convert sf files using st_make_grid (with x = st_as_sf(sf_obj))
st_make_grid(st_as_sf(dd), 
                      square=FALSE,
                      cellsize = 1,
                      n = 200,
                      # crs = prj,
                      flat_topped = T)[st_as_sf(dd)]


# opt 2
# change sf to sp 
ddsp <- day4t$geometry %>% .[1] %>%
  st_buffer(5000) %>% # need to create buffer around obj
  st_zm() %>% as_Spatial()  

# if error, try not using pipe 
ddhex <- HexPoints2SpatialPolygons(sp::spsample(x = ddsp, type = "hexagonal", cellsize = 30000000)) %>% # create spatial sample of points around sp obj and  # convert to hexagons 
  st_as_sf(coords = c("lon","lat"), crs = 4326) # revert back to sf to use in geom_sf() and to transform 

ggplot() + 
  geom_sf(data = ddhex, size = 0.2) +
  geom_hex(data = df, aes(Longitude, Latitude), bins = 500) +
  coord_sf(xlim = c(bbox[1],bbox[3]), ylim = c(bbox[2],bbox[4]))
 


```

Crop plot region to country border   
```{r,aes2, eval = F}
ggplot() +
  borders(regions = "Germany") +
  geom_tile()
```

Add sequential colpal to flight paths/geometry/sf 
```{r, aes3}
inter_df %>% 
    mutate(colpal = path_col %>% rep(7) %>% lighten(seq(0.1,0.5,0.1)))
```


### Hillshade  

```{r, hill1}
require(raster)
dem1 <- getData(country = c("USA"), level=1) # download data
dem1<- getData("SRTM",lat=37.83,lon=-83.68) %>% 
  aggregate(fact=3) # get srtm and reduce res 
dem1 <- "srtm_20_05.tif" %>% raster() # or read from file  
angle_zen <- 40
angle_dir <- 270
quant <- 0.3 # quantile to filter elev data 

dems <- dem1 %>% terrain(opt='slope')
demr <- dem1 %>% terrain(opt='aspect')
demh <- hillShade(dems, demr, angle_zen, angle_dir) 

# conver to df
dem_df <- rasterToPoints(demh) %>% as.data.frame() 
colnames(dem_df) <- c("lon", "lat", "hill")
# take only upper quantile 
dem_df <- dem_df %>% filter(hill > hill %>% quantile(quant),
                            hill < hill %>% quantile(quant+0.1)) # get elev > given quantile

#colpal
colpal <- c(border_col,fg,"#FFFFFF")
cc <- colpal %>% length # number of colour hues 

ggplot() +
  geom_raster(data=dem_df, aes(lon,lat,fill=hill),show.legend = F) 

```

### OSM  
New osm data method  
```{r}
 -------------------------------
# https://www.urbandemographics.org/post/mapping-walking-time-osm-r5r/
osmextract::oe_download(provider = 'openstreetmap_fr',
                        file_url = osmextract::oe_match("Rio De Janeiro")[[1]],
                        download_directory = here::here("data"), force_download = T)

```

### sf structure    

Access levels within sf variable (e.g. Name) using attributes   
```{r, str1}
sf$Name %>% attr(which = "levels")
```

